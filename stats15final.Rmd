---
title: "stats15final"
output:
  pdf_document: default
date: "2022-11-15"
---
FEEL FREE TO CHANGE ANYTHING UP HERE IN THE INTRODUCTION

IMPORTANT: WHEN PUSHING TO GITHUB, DONT PUSH TO MAIN!!!!! MAKE A BRANCH!!!
IF YOU DONT KNOW HOW, READ HERE: https://docs.github.com/en/get-started/quickstart/github-flow

# Section 1: Background and Explanation of Data

### The Austin Animal Center
Our data looks at intakes and outcomes of animals in the Austin Animal Center, which is the primary animal shelter for Austin, TX. They accept strays and owned animals regardless of age or health, and they accept all species and breeds of animals. However, for our analysis, we will be solely looking at the intake and outcomes of dogs at the center.

### Intakes and Outcomes
An _intake_ refers to an instance of an animal being admitted to the shelter, whether it be stray or owned. An _outcome_ refers to an animal leaving the shelter for any reason, whether they are adopted, transferred to another shelter, or pass away while staying in the shelter. Our data consists of two separate tables, one detailing outcomes and one detailing intakes. Each animal has a unique ID that is shared between the two tables.

## Variables

+ Note: the variables started off as being in two separate tables, but they are binded together during cleaning

### Explanatory Variables

***Age***: (char) the dog’s age at the time of the intake/outcome; an estimate if the dog is a rescue

***Breed***: (char) the dog’s primary and secondary breed (if it has one)

***Color***: (char) the dog’s primary and secondary color (if it has one); the one/two main colors that make up its coat

***DateTime***: (char) the date and time of the intake/outcome

### Response Variable

***Type***: (char)  the specifics of the intake/outcome situation for the dog,
ex: 

outcomes: adoption, returned to owner, transferred to another shelter

intakes: stray, owner surrender, public assistance (outside rescue org)

# Section 2: Data Loading, Cleaning, and Modifying

```{r}
library(tidyverse)
library(ggplot2)
library(lubridate)
```

First, we load our data in.

```{r}
austin_intakes <- read.csv("aac_intakes.csv")
austin_outcomes <- read.csv("aac_outcomes.csv")
```

Then, we of course need to limit our dataset to just dogs.

```{r}
outcomes_filter <- austin_outcomes %>%
  filter(Animal.Type=="Dog")
intakes_filter <- austin_intakes %>% 
  filter(Animal.Type=="Dog")

outcomes_filter %>%
  select(Age.upon.Outcome, Animal.Type, Breed) %>%
  head()
```

Then, we need to eliminate all of the unused columns. The `Animal.Type` column will be unused since we've already filtered to just dogs.

```{r}
outcomes_s <- outcomes_filter %>%
  select(Animal.ID, Age.upon.Outcome, Breed, Color, DateTime, Outcome.Type)
intakes_s <- intakes_filter %>%
  select(Animal.ID, Age.upon.Intake, Breed, Color, DateTime, Intake.Type)

outcomes_s %>% 
  select(Age.upon.Outcome, Breed, Color) %>%
  head()
```

Then, we'll be binding the two tables together for the sake of analysis and easier cleaning. An extra column will be added that will specify if each entry is an outcome/intake.

```{r}
o1 <- outcomes_s %>%
  rename("Age"="Age.upon.Outcome",
         "Type"="Outcome.Type")
o1$Action <- "outcome"

i1 <- intakes_s %>%
  rename("Age"="Age.upon.Intake",
         "Type"="Intake.Type")
i1$Action <- "intake"

aac_b <- rbind(o1, i1) %>% arrange(Animal.ID)
aac_b %>%
  select(Age, Breed, Color) %>%
  head()
```


Nex

First, we we'll use `lubridate` to add a column for all of the `DateTime` values converted to `date` objects, which will make it easier to compare them.

```{r}
aac_d <- aac_b
aac_d$DateTime <- mdy_hms(aac_d$DateTime)

aac_d %>% 
  select(Age, Breed, DateTime) %>%
  head()
```

Then, we'll need to do some more careful combing of the data; we'll need to see which animals had intakes/outcomes occur one after the other, without alternating (basically, having two outcomes or two intakes in a row is unusual but it is present in the data)

```{r}
aac_d %>%
  arrange(Animal.ID, DateTime) %>%
  select(Animal.ID, Action, DateTime, Type) %>%
  head()
```

To help with this part of the cleaning, we'll be adding a column that will specify how long each intake/outcome lasted (in seconds) until the next one for each animal. for the first intake/outcome, an NA will be in the column.

```{r}
len <- function(d1, d2)
{
  retval <- int_length(interval(d1, d2))
  return(retval)
}

aac_dd <-
aac_d %>%
  arrange(Animal.ID, DateTime) %>%
  group_by(Animal.ID) %>%
  mutate(num_action=row_number()) %>%
  ungroup() %>%
  mutate(time_from_last_action=case_when(
    (num_action > 1) ~ len(lag(DateTime), DateTime)
  ))

aac_dd %>%
  select(Animal.ID, Action, time_from_last_action)
```

With that, we can simply remove all cases of duplicate entries (i.e. the time from the last action is 0 and it is the same action as the last)

```{r}
aac_f <-
  aac_dd %>%
  filter((time_from_last_action!=0) | (lag(Action)!=Action) | num_action==1) %>%
  arrange(Animal.ID, DateTime) %>%
  mutate(Consecutive=((lag(Action)==Action) & (num_action!=1)))

aac_f %>%
  filter(Consecutive) %>%
  nrow()
```

Now, there are only 69 "consecutive" entries left after filtering; that is to say, 69 entries that are an `outcome` right after an `outcomes` or an `intake` right after an `intake`. Seeing as our table has over 160,000 entries at the moment, just for the sake of analysis, we will be simply removing these entries from the table.

```{r}
aac_r <-
  aac_f  %>%
  filter(!(Consecutive)) %>%
  select(-c(Consecutive, num_action))
```

Next, the "breed" column: it currently has the problem of being a bit too specific, where some breeds are unmixed, some are just labeled "Mix" while others have the breed mix specified, among other naming specifics; this leads to a large majority of the breed categories having <10 entries.

```{r}
aac_r %>%
  group_by(Breed) %>%
  summarise(n=n()) %>%
  ggplot(aes(x=n)) +
  geom_density(fill="light blue") +
  scale_x_log10() +
  xlab("Occurances of each unique breed in data")

aac_r %>%
  group_by(Breed) %>%
  summarise(n=n()) %>%
  summarise(breeds=n())
```

In order for our analysis to be a bit more useful, it will helpful to create less breed categories; we will be removing any "mix" labels and specifying all dog breeds by their primary breed.

```{r}
aac_b <- aac_r %>% 
  mutate(Breed=str_extract(Breed, "^[A-Za-z ]+")) %>% 
  mutate(Breed=str_replace(Breed, " Mix", ""))

aac_b %>%
  group_by(Breed) %>%
  summarise(n=n()) %>%
  ggplot(aes(x=n)) +
  geom_density(fill="light blue") +
  scale_x_log10() +
  xlab("Occurances of each unique breed in data")

aac_b %>%
  group_by(Breed) %>%
  summarise(n=n()) %>%
  summarise(breeds=n())

aac_b %>%
  select(Age, Breed, Color) %>%
  head()
```

However, we run into a similar problem with the `Color` column.

```{r}
aac_b %>%
  group_by(Color) %>%
  summarise(n=n()) %>%
  ggplot(aes(x=n)) +
  geom_density(fill="light blue") +
  scale_x_log10() +
  xlab("Occurances of each unique color in data")

aac_b %>%
  group_by(Color) %>%
  summarise(n=n()) %>%
  summarise(unique_colors=n())
```

So, we'll say that any color that makes up less than 1/100th of the data (in other words, less than 1600 occurrences)will be simplified to be only the first word of the label. The intakes and outcomes tables are similar enough that the counts from the outcomes table will be used as the filter for both.

```{r}
#BIG NOTE: hes defeinitely going to want better justification for the 1/100th figure, and we can certainly change that number but idk what to change it to and like how to justify it but ill figure it out eventually

col_occurances <- 
aac_b %>%
  group_by(Color) %>%
  summarise(Color.Occurances=n())

aac_c <-
  aac_b %>%
  left_join(col_occurances, by = "Color") %>%
  mutate(Color=case_when(
    Color.Occurances<1600 ~ str_extract(Color, "^[A-Za-z]+"),
    Color.Occurances>=1600 ~ Color
  )) %>%
  select(-c(Color.Occurances))

aac_c %>%
  group_by(Color) %>%
  summarise(n=n()) %>%
  ggplot(aes(x=n)) +
  geom_density(fill="light blue") +
  scale_x_log10() +
  xlab("Occurances of each unique color in data")

aac_c %>%
  group_by(Color) %>%
  summarise(n=n()) %>%
  summarise(unique_colors=n())

aac_c %>%
  select(Age, Breed, Color) %>%
  head()
```

Next, note that the `Age` column is made up of character strings at the moment

```{r}
aac_c %>%
  select(Age) %>%
  head()
```

Such a variable will be much easier to analyse as an integer, so we will convert these to integers representing the dog's age in days.

```{r}
conv_to_int <- function(string)
{
  conv <- data.frame(
    c("week", "month", "year"),
    c(7, 30, 365)
  )
  tmp <- 1
  for (n in (1:3))
  {
     if(str_detect(string, conv[n, 1]))
    {
      tmp <- conv[n, 2]
    } 
  }
  ret_str <- str_extract(string, "^[0-9]+")
  ret_int <- as.integer(ret_str)
  return(as.integer(ret_int*tmp))
}

aac_c$Age.Days <- map_int(aac_c$Age, conv_to_int)
#look i know this is slow but fuck it i made it and it works

aac_a <- aac_c %>%
  select(-c(Age)) %>%
  relocate(Age.Days, .before=Breed)
         
aac_a %>%
  select(Age.Days, Breed, Color) %>%
  head()
```
